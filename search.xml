<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringDataJpa-解决N+1条SQL问题（转）]]></title>
    <url>%2F2019%2F04%2F27%2FSpringDataJpa-%E8%A7%A3%E5%86%B3N-1%E6%9D%A1SQL%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[N+1问题当使用@ManyToMany、@ManyToOne、@OneToMany、@OneToOne关联关系的时候，FetchType怎么配置LAZY或者EAGER。SQL真正执行的时候是由一条主表查询和N条子表查询组成的。这种查询效率一般比较低下，比如子对象有N个就会执行N+1条SQL。有时候我们需要用到Left Join或者Inner Join来提高效率，只能通过@Query的JQPL语法实现。Spring Data JPA为了简单地提高查询率，引入了EntityGraph的概念，可以解决N+1条SQL的问题。 Fetch Join在JPA中，我们可以使用fetch join来获取我们需要加载的关联实体。 优点:它只需要一次查询就能够获取到我们需要的所有关联实体。 缺点:不够灵活，选择不同的关联实体就要重写JPQL语句或者是用Criteria API来封装一个很好的接口，当一个对象有很多关联实体的时候，要重写很多的JPQL语句。但如果在实际开发中，关联实体的组合数量较少的情况下是可以用的。 NameEntityGraph 这是JPA2.1的新特性，它的主要作用是来设置懒加载需要加载的关联对象，并且支持多层关联，比如account.getRoles().get(0).getPages(),来获取一个账号的某个角色所能访问的页面。 下面来看一个例子,假如有如下3个类 Account 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Entity@Table(name = ACCOUNT)@NamedEntityGraphs(&#123; @NamedEntityGraph(name = "account.all", attributeNodes = &#123;//attributeNodes 来定义需要懒加载的属性 @NamedAttributeNode("student"), @NamedAttributeNode("staff"),//无延伸 @NamedAttributeNode(value = "roles",//要懒加载roles属性中的pages元素 subgraph = "pages"), &#125;, subgraphs = &#123;//subgraphs 来定义关联对象的属性 @NamedSubgraph(name = "pages",//一层延伸 attributeNodes = @NamedAttributeNode("pages")), @NamedSubgraph(name = "role",//两层延伸 attributeNodes = @NamedAttributeNode( value = "role", subgraph = "pages")) &#125;) &#125;)public class Account extends EntityId &#123; @OneToOne @JoinColumn(name = ACCOUNT_STAFF) private Staff staff; @OneToOne @JoinColumn(name = ACCOUNT_STUDENT) private Student student; @Column private String username; @Column private String password; @ManyToMany(cascade = CascadeType.REFRESH) @JoinTable(name = REL_ACCOUNT_ROLE, joinColumns = &#123; @JoinColumn(name = "accounts", referencedColumnName = "id") &#125;, inverseJoinColumns = &#123; @JoinColumn(name = "roles", referencedColumnName = "id") &#125;) @OrderBy(value = "id DESC") private Set&lt;Role&gt; roles = new HashSet&lt;&gt;(); @OneToMany(mappedBy = "account") private Set&lt;AccountPrivilege&gt; accountPrivileges = new HashSet&lt;&gt;();&#125; Role 12345678910111213141516171819202122@Entity@Table(name = ROLE, uniqueConstraints = @UniqueConstraint(columnNames = &#123; "name" &#125;))public class Role extends EntityId &#123; @Column private String name; @Enumerated private DomainLevel domainLevel; @ManyToMany @JoinTable(name = REL_ACCOUNT_ROLE, joinColumns = &#123; @JoinColumn(name = "roles", referencedColumnName = "id") &#125;, inverseJoinColumns = &#123; @JoinColumn(name = "accounts", referencedColumnName = "id") &#125;) private Set&lt;Account&gt; accounts = new HashSet&lt;&gt;(); @ManyToMany private Set&lt;Page&gt; pages = new HashSet&lt;&gt;();&#125; Page 123456789101112131415161718@Entity@Table(name = PAGE_PRIVILEGE)public class Page &#123; @Id long id; private String pageName; private String url; private String iconClass; private String discription = ""; @ManyToMany(mappedBy = "pages") private Set&lt;Role&gt; roles = new HashSet&lt;&gt;();&#125; 下来我要根据username查询Account，并且需要获取该账号的某个角色能访问的页面，即account.getRoles().get(0).getPages() AccountRepository 123456789@Transactional(readOnly = true)@RepositoryRestResource(exported = false)public interface AccountRepository extends JpaRepository&lt;Account, Long&gt; &#123; //通过@EntityGraph来指定Account类中定义的NamedEntityGraph @EntityGraph(value="account.all",type=EntityGraphType.FETCH) public Account findOneByUsername(String username);&#125; 调用findOneByUsername即能够查询改Account，并且会同时查询出student、staff、roles、roles.pages。查看控制台的话会发现就生成一条sql语句，即只查询一次。 转载自：https://blog.csdn.net/dalangzhonghangxing/article/details/56680629]]></content>
      <categories>
        <category>SpringDataJpa</category>
      </categories>
      <tags>
        <tag>SpringDataJpa</tag>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学SpringSecurity5 第七节：添加记住我功能]]></title>
    <url>%2F2019%2F04%2F27%2F%E9%87%8D%E5%AD%A6SpringSecurity5%20%E7%AC%AC%E4%B8%83%E8%8A%82%EF%BC%9A%E6%B7%BB%E5%8A%A0%E8%AE%B0%E4%BD%8F%E6%88%91%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[记住我基本原理 TokenRepositorySpringSecurity为我们提供了两种实现方式 JdbcTokenRepositoryImpl 数据库 InMemoryTokenRepositoryImpl 内存 我们本次采用JdbcTokenRepositoryImpl来实现 RememberMeAuthenticationFilter]]></content>
      <categories>
        <category>重学SpringSecurity5</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学SpringSecurity5（六）：图片验证码]]></title>
    <url>%2F2019%2F04%2F26%2F%E9%87%8D%E5%AD%A6SpringSecurity5%20%E7%AC%AC%E5%85%AD%E8%8A%82%EF%BC%9A%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[图形验证码验证编写流程 编写获取验证码接口 编写过滤器，在UsernamePasswordAuthenticationFilter前对验证码进行校验 修改配置，将其添加到SpringSecurity过滤器链中 获取验证码接口编写生成随机验证码和图片工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class ImageValidateCodeUtils &#123; public static final int WIDTH = 60; public static final int HEIGHT = 20; private static char mapTable[] = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'&#125;; public static String generateCode(int length) &#123; String code = ""; for (int i = 0; i &lt; length; i++) &#123; code += mapTable[(int) (mapTable.length * Math.random())]; &#125; return code; &#125; public static BufferedImage generateImage(String code) &#123; BufferedImage image = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_INT_RGB); // 获取图形上下文 Graphics g = image.getGraphics(); //生成随机类 Random random = new Random(); // 设定背景色 g.setColor(getRandColor(200, 250)); g.fillRect(0, 0, WIDTH, HEIGHT); //设定字体 g.setFont(new Font("Times New Roman", Font.PLAIN, 18)); // 随机产生168条干扰线，使图象中的认证码不易被其它程序探测到 g.setColor(getRandColor(160, 200)); for (int i = 0; i &lt; 168; i++) &#123; int x = random.nextInt(WIDTH); int y = random.nextInt(HEIGHT); int xl = random.nextInt(12); int yl = random.nextInt(12); g.drawLine(x, y, x + xl, y + yl); &#125; // 将认证码显示到图象中 g.setColor(new Color(20 + random.nextInt(110), 20 + random.nextInt(110), 20 + random.nextInt(110))); // 直接生成 // 设置随便码在背景图图片上的位置 for (int i = 0; i &lt; code.length(); i++) &#123; // 将认证码显示到图象中 g.setColor(new Color(20 + random.nextInt(110), 20 + random.nextInt(110), 20 + random.nextInt(110))); // 直接生成 String str = code.substring(i, i + 1); // 设置随便码在背景图图片上的位置 g.drawString(str, 13 * i + 6, 15); &#125; g.dispose(); return image; &#125; //给定范围获得随机颜色 private static Color getRandColor(int fc, int bc) &#123; Random random = new Random(); if (fc &gt; 255) fc = 255; if (bc &gt; 255) bc = 255; int r = fc + random.nextInt(bc - fc); int g = fc + random.nextInt(bc - fc); int b = fc + random.nextInt(bc - fc); return new Color(r, g, b); &#125;&#125; 新增获取验证码接口1234567891011121314public class ValidateCodeImg &#123; private String code; private LocalDateTime expireTime; public ValidateCodeImg(String code, LocalDateTime expireTime) &#123; this.code = code; this.expireTime = expireTime; &#125; public String getCode() &#123; return code; &#125; public LocalDateTime getExpireTime() &#123; return expireTime; &#125;&#125; 12345678910111213141516@RestControllerpublic class ValidateCodeController &#123; private SessionStrategy sessionStrategy = new HttpSessionSessionStrategy(); public static final String SESSION_SAVE_KEY = "VALDATE_CODE"; @GetMapping("/validate/imagecode") public void createImageCode(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; String generateCode = ImageValidateCodeUtils.generateCode(4); ValidateCodeImg validateCodeImg = new ValidateCodeImg(generateCode, LocalDateTime.now().plusSeconds(60)); sessionStrategy.setAttribute(new ServletWebRequest(request), SESSION_SAVE_KEY, validateCodeImg); response.setContentType("image/jpeg"); ImageIO.write(ImageValidateCodeUtils.generateImage(generateCode), "JPEG", response.getOutputStream()); &#125;&#125; 编写过滤器123456789101112131415161718192021222324252627282930313233343536373839404142public class ValidateCodeFilter extends OncePerRequestFilter &#123; private SessionStrategy sessionStrategy = new HttpSessionSessionStrategy(); private AuthenticationFailureHandler authenticationFailureHandler; public ValidateCodeFilter(AuthenticationFailureHandler authenticationFailureHandler) &#123; this.authenticationFailureHandler = authenticationFailureHandler; &#125; @Override protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException &#123; if("POST".equalsIgnoreCase(httpServletRequest.getMethod()) &amp;&amp; "/authentication/form".equalsIgnoreCase(httpServletRequest.getRequestURI())) &#123; try &#123; String validatecode = ServletRequestUtils.getStringParameter(httpServletRequest, "validatecode"); ValidateCodeImg validateCodeImg = (ValidateCodeImg) sessionStrategy.getAttribute(new ServletWebRequest(httpServletRequest), ValidateCodeController.SESSION_SAVE_KEY); if (validatecode == null || validatecode.isEmpty()) &#123; throw new ValidateCodeException("验证码不能为空"); &#125; if (validateCodeImg == null) &#123; throw new ValidateCodeException("请先获取验证码"); &#125; if (validateCodeImg.getExpireTime().isBefore(LocalDateTime.now())) &#123; throw new ValidateCodeException("验证码已过期，请重新获取"); &#125; if (!validateCodeImg.getCode().equals(validatecode)) &#123; throw new ValidateCodeException("验证码错误"); &#125; sessionStrategy.removeAttribute(new ServletWebRequest(httpServletRequest), ValidateCodeController.SESSION_SAVE_KEY); &#125; catch (ValidateCodeException e) &#123; authenticationFailureHandler.onAuthenticationFailure(httpServletRequest, httpServletResponse, e); &#125; &#125; filterChain.doFilter(httpServletRequest,httpServletResponse); &#125;&#125; 修改配置12345678910111213141516171819202122@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; ValidateCodeFilter validateCodeFilter = new ValidateCodeFilter(myAuthenticationFailureHandler); http.addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class) .formLogin() .loginPage("/authentication/require") .loginProcessingUrl("/authentication/form") .successHandler(myAuthenticationSuccessHandler) .failureHandler(myAuthenticationFailureHandler) .and() .authorizeRequests() .antMatchers( "/mylogin.html", "/validate/imagecode", "/authentication/require").permitAll() .anyRequest().authenticated() .and() .csrf().disable();&#125;]]></content>
      <categories>
        <category>重学SpringSecurity5</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>SpringSecurity</tag>
        <tag>图片验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学SpringSecurity5（五）：认证流程原理]]></title>
    <url>%2F2019%2F04%2F23%2F%E9%87%8D%E5%AD%A6SpringSecurity5%20%E7%AC%AC%E4%BA%94%E8%8A%82%EF%BC%9A%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[认证处理流程说明 UsernamePasswordAuthenticationFilter12345678910111213141516171819202122...public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123; if (this.postOnly &amp;&amp; !request.getMethod().equals("POST")) &#123; throw new AuthenticationServiceException("Authentication method not supported: " + request.getMethod()); &#125; else &#123; String username = this.obtainUsername(request); String password = this.obtainPassword(request); if (username == null) &#123; username = ""; &#125; if (password == null) &#123; password = ""; &#125; username = username.trim(); UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password); this.setDetails(request, authRequest); return this.getAuthenticationManager().authenticate(authRequest); &#125;&#125;... 表单登录的第一步，首先进入该方法，该方法主要的逻辑为： 判断是否为POST方法 判断用户名密码是否为空 创建一个UsernamePasswordAuthenticationToken setDetails会将请求的一些信息放入上一步创建的UsernamePasswordAuthenticationToken中 调用AuthenticationManager UsernamePasswordAuthenticationToken通过查看其继承关系，它其实是AbstractAuthenticationToken的一个子类，而AbstractAuthenticationToken是一个实现了Authentication接口的抽象类 我们首先来看一下它的构造方法 123456public UsernamePasswordAuthenticationToken(Object principal, Object credentials) &#123; super(null); this.principal = principal; this.credentials = credentials; setAuthenticated(false);&#125; 首先，先调用父类的构造方法，传入null，然后将username和password缓存 然后将Authenticated设置为false，意为未认证 1234567891011121314151617public AbstractAuthenticationToken(Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; if (authorities == null) &#123; this.authorities = AuthorityUtils.NO_AUTHORITIES; return; &#125; for (GrantedAuthority a : authorities) &#123; if (a == null) &#123; throw new IllegalArgumentException( "Authorities collection cannot contain any null elements"); &#125; &#125; ArrayList&lt;GrantedAuthority&gt; temp = new ArrayList&lt;&gt;( authorities.size()); temp.addAll(authorities); this.authorities = Collections.unmodifiableList(temp);&#125; 打开父类的构造方法，发现其要求传入一个权限列表 当前为未认证状态，所以并不知道拥有哪些权限，所以此时传入null AuthenticationManagerAuthenticationManager其实只是一个管理类，管理众多的AuthenticationProvider，通过查看其实现类ProviderManager源码中的关键代码可以看到 12345678910111213141516171819202122232425public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; Class&lt;? extends Authentication&gt; toTest = authentication.getClass(); ... for (AuthenticationProvider provider : getProviders()) &#123; if (!provider.supports(toTest)) &#123; continue; &#125; if (debug) &#123; logger.debug("Authentication attempt using " + provider.getClass().getName()); &#125; try &#123; result = provider.authenticate(authentication); if (result != null) &#123; copyDetails(authentication, result); break; &#125; &#125; catch ... ... &#125; ...&#125; 它完成的工作是依次调用所有的AuthenticationProvider的supports方法，将Authentication对象传入，查看这个provider是否支持处理这种类型的Authentication来进行认证 如果发现可以来处理该认证方式的AuthenticationProvider，则会去调用其的authenticate方法 AuthenticationProvider我们当前的认证方式，与其匹配的AuthenticationProvider为DaoAuthenticationProvider，我们查看其源代码发现其并没有重写authenticate方法，而沿用其父类AbstractUserDetailsAuthenticationProvider的authenticate方法，我们查看其源代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public abstract class AbstractUserDetailsAuthenticationProvider implements AuthenticationProvider, InitializingBean, MessageSourceAware &#123; ... public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; ... if (user == null) &#123; cacheWasUsed = false; try &#123; user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication); &#125; catch... &#125; try &#123; preAuthenticationChecks.check(user); additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication); &#125; catch (AuthenticationException exception) &#123; if (cacheWasUsed) &#123; // There was a problem, so try again after checking // we're using latest data (i.e. not from the cache) cacheWasUsed = false; user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication); preAuthenticationChecks.check(user); additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication); &#125; else &#123; throw exception; &#125; &#125; postAuthenticationChecks.check(user); if (!cacheWasUsed) &#123; this.userCache.putUserInCache(user); &#125; Object principalToReturn = user; if (forcePrincipalAsString) &#123; principalToReturn = user.getUsername(); &#125; return createSuccessAuthentication(principalToReturn, authentication, user); &#125; ...&#125; 我们可以看到它先调用了retrieveUser方法，通过查看，该方法属于抽象方法，DaoAuthenticationProvider的实现如下 1234567891011121314protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123; prepareTimingAttackProtection(); try &#123; UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username); if (loadedUser == null) &#123; throw new InternalAuthenticationServiceException( "UserDetailsService returned null, which is an interface contract violation"); &#125; return loadedUser; &#125; catch...&#125; 可以看到这么一句getUserDetailsService().loadUserByUsername(username) 这便是我们之前实现的UserDetailsService中的方法，根据用户名获取UserDetails实例 接下来从UserDetailsService中拿到用户实例后，便执行了preAuthenticationChecks.check(user)，对用户进行预检查 我们查看其源代码 123456789101112131415161718192021222324252627private class DefaultPreAuthenticationChecks implements UserDetailsChecker &#123; public void check(UserDetails user) &#123; if (!user.isAccountNonLocked()) &#123; logger.debug("User account is locked"); throw new LockedException(messages.getMessage( "AbstractUserDetailsAuthenticationProvider.locked", "User account is locked")); &#125; if (!user.isEnabled()) &#123; logger.debug("User account is disabled"); throw new DisabledException(messages.getMessage( "AbstractUserDetailsAuthenticationProvider.disabled", "User is disabled")); &#125; if (!user.isAccountNonExpired()) &#123; logger.debug("User account is expired"); throw new AccountExpiredException(messages.getMessage( "AbstractUserDetailsAuthenticationProvider.expired", "User account has expired")); &#125; &#125;&#125; 可以看到，其对我们之前实现的UserDetails中的四个boolean方法中的三个进行了检查(锁定，启用，账户过期) 接下来接着看AbstractUserDetailsAuthenticationProvider类中的authenticate方法，其在做完预检查后执行了以下一句话：additionalAuthenticationChecks(user, authentication) 对用户进行附加检查，我们通过查看其源代码 123456789101112131415161718192021protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException &#123; if (authentication.getCredentials() == null) &#123; logger.debug("Authentication failed: no credentials provided"); throw new BadCredentialsException(messages.getMessage( "AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials")); &#125; String presentedPassword = authentication.getCredentials().toString(); if (!passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123; logger.debug("Authentication failed: password does not match stored value"); throw new BadCredentialsException(messages.getMessage( "AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials")); &#125;&#125; 可以看到在这里调用了PasswordEncoder的matches方法来验证密码是否匹配 最后调用了postAuthenticationChecks.check(user)来进行最后一次检查，查看其源代码 1234567891011private class DefaultPostAuthenticationChecks implements UserDetailsChecker &#123; public void check(UserDetails user) &#123; if (!user.isCredentialsNonExpired()) &#123; logger.debug("User account credentials have expired"); throw new CredentialsExpiredException(messages.getMessage( "AbstractUserDetailsAuthenticationProvider.credentialsExpired", "User credentials have expired")); &#125; &#125;&#125; 检查了该账户的凭证(密码)是否过期，也就是我们的UserDetails中的其中一个boolean方法，加上之前的预检查，UserDetails中的四个返回值为boolean的方法至此已检查完毕 当所有检查都通过后，就认为用户认证是成功的，最终会返回createSuccessAuthentication(principalToReturn, authentication, user)，通过查看其源码，本质就是再次调用了UsernamePasswordAuthenticationToken的构造方法，但是与之前不同的是，这次调用的是UsernamePasswordAuthenticationToken的三个参数的构造方法： 1234567public UsernamePasswordAuthenticationToken(Object principal, Object credentials, Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; super(authorities); this.principal = principal; this.credentials = credentials; super.setAuthenticated(true); // must use super, as we override&#125; 即多传入了用户的权限，以及setAuthenticated为true，表明认证已成功 此时认证流程已经结束，这个UsernamePasswordAuthenticationToken将会被返回至UsernamePasswordAuthenticationFilter中 在完成认证流程后，AbstractAuthenticationProcessingFilter会调用successfulAuthentication(request, response, chain, authResult)方法，查看其源代码可以发现其最终调用的是successHandler.onAuthenticationSuccess(request, response, authResult)，这便是我们上一节配置的处理验证成功的handler 以上为验证成功的处理流程，如果在三次检查的过程中，有任何一处未通过，会抛出AuthenticationException它的子类异常，会被AbstractAuthenticationProcessingFilter捕获到，进入到认证失败的流程，即调用unsuccessfulAuthentication(request, response, exception)方法，通过查看源代码可以看到其最终调用了failureHandler.onAuthenticationFailure(request, response, failed)，也就是我们上一节配置的处理验证失败的handler 认证结果如何在多个请求之间共享 在进行认证并且认证成功的最后一步，即在AbstractAuthenticationProcessingFilter中的doFilter方法调用successfulAuthentication(request, response, chain, authResult)时 12345678910111213protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug("Authentication success. Updating SecurityContextHolder to contain: " + authResult); &#125; SecurityContextHolder.getContext().setAuthentication(authResult); this.rememberMeServices.loginSuccess(request, response, authResult); if (this.eventPublisher != null) &#123; this.eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass())); &#125; this.successHandler.onAuthenticationSuccess(request, response, authResult);&#125; 可以看到一句话SecurityContextHolder.getContext().setAuthentication(authResult)，这便是将认证结果即Authentication对象放入SecurityContext中，再将其放入SecurityContextHolder的过程 SecurityContext1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class SecurityContextImpl implements SecurityContext &#123; private static final long serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID; // ~ Instance fields // ================================================================================================ private Authentication authentication; public SecurityContextImpl() &#123;&#125; public SecurityContextImpl(Authentication authentication) &#123; this.authentication = authentication; &#125; // ~ Methods // ======================================================================================================== @Override public boolean equals(Object obj) &#123; if (obj instanceof SecurityContextImpl) &#123; SecurityContextImpl test = (SecurityContextImpl) obj; if ((this.getAuthentication() == null) &amp;&amp; (test.getAuthentication() == null)) &#123; return true; &#125; if ((this.getAuthentication() != null) &amp;&amp; (test.getAuthentication() != null) &amp;&amp; this.getAuthentication().equals(test.getAuthentication())) &#123; return true; &#125; &#125; return false; &#125; @Override public Authentication getAuthentication() &#123; return authentication; &#125; @Override public int hashCode() &#123; if (this.authentication == null) &#123; return -1; &#125; else &#123; return this.authentication.hashCode(); &#125; &#125; @Override public void setAuthentication(Authentication authentication) &#123; this.authentication = authentication; &#125; @Override public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append(super.toString()); if (this.authentication == null) &#123; sb.append(": Null authentication"); &#125; else &#123; sb.append(": Authentication: ").append(this.authentication); &#125; return sb.toString(); &#125;&#125; 通过查看其实现类SecurityContextImpl的源码，可以发现其实它就是一个对于Authentication的封装，并重写了其toString()方法和equals()方法 SecurityContextHolder通过查看其源码，可以看到它其实就是对于SecurityContextHolderStrategy的一次封装，而SecurityContextHolderStrategy的默认实现，实际上就是一个ThreadLocal的封装，所以其本质上就相当于是一个ThreadLocal 关于ThreadLocal，其实它就是一种将变量和线程绑定的方式，在每个线程中都存在一个线程安全的变量，具体可以查看深入理解 ThreadLocal SecurityContextPersistenceFilter 它在SpringSecurity过滤器链上的位置如上图所示，位于过滤器链的最前面，其主要作用如下： 当请求进入SpringSecurity过滤器链时，检查session中是否存在SecurityContext，如果有，就将其放入线程中 当响应返回用户时，检查线程中是否有SecurityContext，如果有，就将其放入session中 获取认证用户信息显式使用SecurityContextHolder获取我们知道，用户登录后的Authentication就保存在SecurityContextHolder中，我们可以直接获取 1234@GetMapping("/me")public Object getCurrentUser() &#123; return SecurityContextHolder.getContext().getAuthentication();&#125; 参数注入SpringSecurity为我们提供了自动的参数注入，直接添加Authentication参数，Spring框架会为我们自动注入 1234@GetMapping("/me")public Object getCurrentUser(Authentication authentication) &#123; return authentication;&#125; 返回的信息太多？只需要UserDetails相关信息使用默认的Authentication，会返回大量信息，例如IP、SessionId等，有时我们并不需要这么多信息，只需要UserDetails的信息，那我们可以这样做： 1234@GetMapping("/me")public Object getCurrentUser(@AuthenticationPrincipal UserDetails userDetails) &#123; return userDetails;&#125; 这样就只会获取到UserDetails的信息了]]></content>
      <categories>
        <category>重学SpringSecurity5</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学SpringSecurity5（四）：个性化用户认证流程]]></title>
    <url>%2F2019%2F04%2F23%2F%E9%87%8D%E5%AD%A6SpringSecurity5%20%E7%AC%AC%E5%9B%9B%E8%8A%82%EF%BC%9A%E4%B8%AA%E6%80%A7%E5%8C%96%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[实现个性化登录页面在WebSecurityConfig中修改如下配置 1234567891011121314@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() .loginPage("/mylogin.html") //设置登录页面路径 .loginProcessingUrl("/authentication/form") //设置认证路径 .and() .authorizeRequests() .antMatchers("/mylogin.html").permitAll() //放行/mylogin.html访问 .anyRequest().authenticated() .and() .csrf().disable();&#125; 在resources目录下新建resources/mylogin.html文件 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;我的个性化登录页面&lt;/h2&gt; &lt;form action="/authentication/form" method="post"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名：&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="username"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码：&lt;/td&gt; &lt;td&gt;&lt;input type="password" name="password"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt;&lt;input type="submit" value="登录"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 处理不同类型的请求功能流程图 代码实现BrowserSecurityController.java 12345678910111213141516171819202122232425262728@RestControllerpublic class BrowserSecurityController &#123; private Logger logger = LoggerFactory.getLogger(BrowserSecurityController.class); private RequestCache requestCache = new HttpSessionRequestCache(); private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy(); @RequestMapping("/authentication/require") @ResponseStatus(code = HttpStatus.UNAUTHORIZED) public SimpleResponse requireAuthentication(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; //获取springsecurity缓存的request SavedRequest savedRequest = requestCache.getRequest(request, response); if (savedRequest != null) &#123; String target = savedRequest.getRedirectUrl(); logger.info("引发跳转的请求是：&#123;&#125;", target); //判断用户访问的路径是否以.html结尾 if(StringUtils.endsWithIgnoreCase(target, ".html")) &#123; //重定向到登录页面 redirectStrategy.sendRedirect(request, response, "/mylogin.html"); &#125; &#125; //返回JSON return new SimpleResponse("访问的服务需要身份认证"); &#125;&#125; SimpleResponse.java 12345678910111213141516public class SimpleResponse &#123; public SimpleResponse(Object content) &#123; this.content = content; &#125; private Object content; public Object getContent() &#123; return content; &#125; public void setContent(Object content) &#123; this.content = content; &#125;&#125; WebSecurityConfig.java 123456789101112131415@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() .loginPage("/authentication/require") .loginProcessingUrl("/authentication/form") .and() .authorizeRequests() .antMatchers("/mylogin.html").permitAll() .antMatchers("/authentication/require").permitAll() .anyRequest().authenticated() .and() .csrf().disable();&#125; 自定义登录成功/失败处理SpringSecurity为我们提供了两个接口：AuthenticationSuccessHandler，AuthenticationFailureHandler，这两个接口就是用来自定义成功和失败的逻辑 分别来实现一下： MyAuthenticationSuccessHandler.java 123456789101112131415@Component("myAuthenticationSuccessHandler")public class MyAuthenticationSuccessHandler implements AuthenticationSuccessHandler &#123; private Logger logger = LoggerFactory.getLogger(getClass()); @Autowired private ObjectMapper objectMapper; @Override public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException &#123; logger.info("登录成功"); httpServletResponse.setContentType("application/json;charset=UTF-8"); httpServletResponse.getWriter().write(objectMapper.writeValueAsString(authentication)); &#125;&#125; MyAuthenticationFailureHandler.java 12345678910111213141516@Component("myAuthenticationFailureHandler")public class MyAuthenticationFailureHandler implements AuthenticationFailureHandler &#123; private Logger logger = LoggerFactory.getLogger(getClass()); @Autowired private ObjectMapper objectMapper; @Override public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException &#123; logger.info("登录失败"); httpServletResponse.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value()); httpServletResponse.setContentType("application/json;charset=UTF-8"); httpServletResponse.getWriter().write(objectMapper.writeValueAsString(e)); &#125;&#125; 最后在WebSecurityConfig中配置一下 1234567891011121314151617181920212223@Autowiredprivate AuthenticationSuccessHandler myAuthenticationSuccessHandler;@Autowiredprivate AuthenticationFailureHandler myAuthenticationFailureHandler;@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() .loginPage("/authentication/require") .loginProcessingUrl("/authentication/form") .successHandler(myAuthenticationSuccessHandler) .failureHandler(myAuthenticationFailureHandler) .and() .authorizeRequests() .antMatchers("/mylogin.html").permitAll() .antMatchers("/authentication/require").permitAll() .anyRequest().authenticated() .and() .csrf().disable();&#125;]]></content>
      <categories>
        <category>重学SpringSecurity5</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备战面试-Redis篇]]></title>
    <url>%2F2019%2F04%2F22%2F%E5%A4%87%E6%88%98%E9%9D%A2%E8%AF%95-Redis%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Redis简介主流应用架构(缓存层) 缓存中间件——Memcache和Redis的区别Memcache：代码层次类似Hash 支持简单数据类型 不支持数据持久化存储 不支持主从 不支持分片 Redis 数据类型丰富 支持数据磁盘持久化存储 支持主从 支持分片 为什么Redis能这么快100000+QPS(QPS即query per second，每秒内查询次数) 完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高 数据结构简单，对数据操作也简单 采用单线程，单线程也能处理高并发请求，想多核也可以启动多实例 使用多路I/O复用模型，非阻塞IO 多路I/O复用模型FD：File Descriptor，文件描述符一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据到文件本身的映射 传统的阻塞I/O模型 Select系统调用 Redis采用的I/O多路复用函数epoll/kqueue/evport/select？ 因地制宜 优先选择时间复杂度为O(1)的I/O多路复用函数作为底层实现 以时间复杂度为O(n)的select作为保底 基于react设计模式监听I/O事件 Redis常用数据类型供用户使用的数据类型 String：最基本的数据类型，二进制安全（最大能存储512M） Hash：String元素组成的字典，适合用于存储对象 List：列表，按照String元素插入顺序排序 Set：String元素组成的无序集合，通过哈希表实现，不允许重复 Sorted Set：通过分数来为集合中的成员进行从小到大的排序 用于计数的HyperLogLog，用于支持存储地理位置信息的Geo 底层数据类型基础 简单动态字符串 链表 字典 跳跃表 整数集合 压缩列表 对象 从海量key里查询出某一固定前缀的key留意细节 摸清数据规模，即问清楚边界 批量生成redis测试数据1.linux bash下执行： 1for((i=1;i&lt;=20000000;i++));do echo "set k$i v$i" &gt;&gt; /tmp/redisTest.txt 生成2千万条redis批量设置kv的语句(key=kn,value=vn)写入到/tmp目录下的redisTest.txt文件中 2.用vim去掉行尾的^M符号，使用方式如下： 123vim /tmp/redisTest.txt:set fileformat=dos #设置文件的格式，通过这句话去掉每行结尾的^M符号:wq #保存退出 3.通过redis提供的管道–pipe形式，去跑redis，传入文件的指令批量灌数据，需要花费一段时间 1cat /tmp/redisTest.txt | 路径/redis-5.0.0/src/redis-cli -h 主机ip -p 端口号 --pipe KEYS pattern查找所有符合给定模式pattern的key KEYS指令一次性返回所有匹配的key 键的数量过大会使服务卡顿 SCAN cursor [MATCH pattern] [COUNT count] 基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程 以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历 不保证每次执行都返回某个给定数量的元素，支持模糊查询 一次返回的数量不可控，只能是大概率符合count参数 如何通过Redis实现分布式锁分布式锁需要解决的问题 互斥性 安全性 死锁 容错 如何通过Redis实现SETNX key value如果key不存在，则创建并赋值 时间复杂度：O(1) 返回值：设置成功，返回1；设置失败，返回0 如何解决SETNX长期有效的问题EXPIRE key seconds（错误的解法） 设置key的生存时间，当key过期时(生存时间为0)，会被自动删除 缺点：原子性得不到满足 1234567RedisService redisService = SpringUtils.getBean(RedisService.class);long status = redisService.setnx(key, "1");if(status == 1) &#123; redisService.expire(key, expire); //执行独占资源逻辑 doOcuppiedWork()&#125; SET key value [EX seconds] [PX milliseconds] [NX|XX] EX second：设置键的过期时间为second秒 PX millisecond：设置键的过期时间为millisecond毫秒 NX：只在键不存在时，才对键进行设置操作 XX：只在键已经存在时，才对键进行设置操作 SET操作成功完成时，返回OK，否则返回nil 123456RedisService redisService = SpringUtils.getBean(RedisService.class);String result = redisService.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);if("ok".equals(result)) &#123; //执行独占资源逻辑 doOcuppiedWork()&#125; 大量的key同时过期的注意事项集中过期，由于清除大量的key很耗时，会出现短暂的卡顿现象 解决方案：在设置key的过期时间的时候，给每个key加上随机值 如何使用Redis做异步队列使用List作为队列，RPUSH生产消息，LPOP消费消息 缺点：没有等待队列里有值就直接消费 弥补：可以通过在应用层引入Sleep机制去调用LPOP重试]]></content>
      <categories>
        <category>备战面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringDataJpa-自动生成分布式高效主键ID]]></title>
    <url>%2F2019%2F04%2F20%2FSpringDataJpa-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E6%95%88%E4%B8%BB%E9%94%AEID%2F</url>
    <content type="text"><![CDATA[是根据分布式高效ID生产黑科技(sequence)的算法实现的 首先将该项目中的两个关键文件复制进自己的项目 Sequence.java SystemClock.java 然后新建一个SnowflakeIdentifierGenerator类 12345678910111213141516171819202122232425public class SnowflakeIdentifierGenerator implements IdentifierGenerator, Configurable &#123; private Sequence sequence; @Override public void configure(Type type, Properties params, ServiceRegistry serviceRegistry) throws MappingException &#123; ConfigurationService configurationService = serviceRegistry.getService(ConfigurationService.class); long workerId = Long.parseLong(configurationService.getSetting( "hibernate.custom.workerId", String.class, "-1" )); long datacenterId = Long.parseLong(configurationService.getSetting( "hibernate.custom.datacenterId", String.class, "-1" )); sequence = new Sequence(workerId, datacenterId); &#125; @Override public Serializable generate(SharedSessionContractImplementor session, Object object) throws HibernateException &#123; return String.valueOf(sequence.nextId()); &#125;&#125; 我们这里的workerId和datacenterId采用配置文件读取的方式进行读取，在application.yml中加入如下配置： 1234567spring: jpa: properties: hibernate: custom: workerId: 1 datacenterId: 1 最后新建一个AbstractBaseEntity作为实体类的统一父类 1234567891011121314151617181920@MappedSuperclasspublic abstract class AbstractBaseEntity &#123; @Id @GeneratedValue(generator = "snowflakeIdentifierGenerator") @GenericGenerator( name = "snowflakeIdentifierGenerator", strategy = "SnowflakeIdentifierGenerator的完整路径(包名.类名)" ) @Column(name = "id", length = 32) private String id; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125;&#125; 完成之后，所有的实体类只需要继承于该类，就可以自动生成ID了，在不同的微服务中，可以使用不同的workerId和datacenterId，从而实现分布式高效主键ID]]></content>
      <categories>
        <category>SpringDataJpa</category>
      </categories>
      <tags>
        <tag>SpringDataJpa</tag>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>sequence</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学SpringSecurity5（三）：自定义用户认证]]></title>
    <url>%2F2019%2F04%2F20%2F%E9%87%8D%E5%AD%A6SpringSecurity5%20%E7%AC%AC%E4%B8%89%E8%8A%82%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[自定义用户认证流程首先回想一下我们最早学习java web的时候，是怎么做登录认证的。 首先制作登录页面(login.html)和登录认证endpoint(LoginController) 填写用户名、密码后Post提交表单给LoginController进行认证 java后台编写UserService、UserDao，根据用户名、密码搜索数据库判断用户信息。如果符合条件，则将用户信息存入session，并设置cookie存储jsessionid，失效时间为半小时，跳转到主页；如果不符合条件重新定位到login.html 用户登录成功后，带着cookie横行无阻，因为自定义过滤器UserFilter判断session中是否有用户信息，有就放行。 用户执行注销操作，java后台清除session和cookie，并跳转到登录页面。 Spring Security其实就是帮我们封装了一些类，简化了我们的代码。如果按照Spring Security的思路来做登录认证，应该是下面这样 用户编写WebSecurityConfigurerApdater的继承类，配置HttpSecurity，包括formLogin，antMatcher，hasRole等等。 项目启动自动装配FilterChain，访问不同uri对应不同的Filter Chain。 用户输入账号、密码点击登录，FilterChainProxy中的UsernamePasswordAuthenticationFilter获取request中的用户名、密码，验证身份信息 doFilter()过程中会执行ProviderManager.authenticate()，即遍历所有AuthenticationProvider执行authenticate()方法。 authenticate()方法中会调用userDetailService，用户自定义类继承UserDetailService，并重写其中的方法loadUserByUsername()，从数据库中获取用户信息进行比对 比对成功后将用户信息和角色信息整合成Authentication，并存入SecurityContext中，同时将SecurityContext也存入session中，跳转到主页面。 比对失败，SecurityContext中没有Authentication，FilterChain进行到最后一步FilterSecurityInterceptor，判断用户角色是否能访问request中的访问地址即资源。如果不行则报错跳转到指定页面；如果成功则进入request调用的资源。 注销操作由LogoutFilter执行，执行session.invalidate()和SecurityContextHolder.clearContext()。 RBAC数据库设计数据库设计 使用SpringDataJpa自动生成表AbstractBaseEntity详见SpringDataJpa-自动生成分布式高效主键ID User表12345678910111213141516171819202122232425262728293031323334@Entity(name = "uaa_t_user")@Table(name = "uaa_t_user")public class User extends AbstractBaseEntity &#123; @Column(name = "username", length = 32) private String username; @Column(name = "password", length = 256) private String password; @Column(name = "account_non_expired", columnDefinition = "TINYINT(1) UNSIGNED") private Boolean accountNonExpired = true; @Column(name = "account_non_locked", columnDefinition = "TINYINT(1) UNSIGNED") private Boolean accountNonLocked = true; @Column(name = "credentials_non_expired", columnDefinition = "TINYINT(1) UNSIGNED") private Boolean credentialsNonExpired = true; @Column(name = "enabled", columnDefinition = "TINYINT(1) UNSIGNED") private Boolean enabled = true; @ManyToMany(cascade = &#123; CascadeType.MERGE &#125;, fetch = FetchType.LAZY) @JoinTable( name = "uaa_r_user_role", joinColumns = @JoinColumn(name = "user_id", referencedColumnName = "id", foreignKey = @ForeignKey(name = "none", value = ConstraintMode.NO_CONSTRAINT)), inverseJoinColumns = @JoinColumn(name = "role_id", referencedColumnName = "id", foreignKey = @ForeignKey(name = "none", value = ConstraintMode.NO_CONSTRAINT)) ) private Set&lt;Role&gt; roles = new HashSet&lt;&gt;(); getter...setter...&#125; Role表12345678910111213141516171819202122@Entity(name = "uaa_t_role")@Table(name = "uaa_t_role")public class Role extends AbstractBaseEntity &#123; @Column(name = "role_name", length = 32) private String roleName; @Column(name = "description", length = 255) private String description; @ManyToMany(cascade = &#123; CascadeType.MERGE &#125;, fetch = FetchType.LAZY) @JoinTable( name = "uaa_r_role_authority", joinColumns = @JoinColumn(name = "role_id", referencedColumnName = "id", foreignKey = @ForeignKey(name = "none", value = ConstraintMode.NO_CONSTRAINT)), inverseJoinColumns = @JoinColumn(name = "authority_id", referencedColumnName = "id", foreignKey = @ForeignKey(name = "none", value = ConstraintMode.NO_CONSTRAINT)) ) private Set&lt;Authority&gt; authorities = new HashSet&lt;&gt;(); getter...setter...&#125; Authority表123456789101112@Entity(name = "uaa_t_authority")@Table(name = "uaa_t_authority")public class Authority extends AbstractBaseEntity &#123; @Column(name = "authority_name", length = 32) private String authorityName; @Column(name = "description", length = 255) private String description; getter...setter...&#125; application.yml12345678910111213141516171819202122server: port: 8080spring: datasource: url: #url username: #username password: #password jpa: hibernate: ddl-auto: create #第一次项目启动时使用create创建表格，后面可以使用update database-platform: org.hibernate.dialect.MySQL5InnoDBDialect #调整生成的表的引擎为InnoDB show-sql: true generate-ddl: true properties: hibernate: enable_lazy_load_no_trans: true event: merge: entity_copy_observer: allow custom: workerId: 1 datacenterId: 1 N+1条SQL问题详见SpringDataJpa-解决N+1条SQL问题 自定义用户认证实现UserDetails1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980@Entity(name = "uaa_t_user")@Table(name = "uaa_t_user")public class User extends AbstractBaseEntity implements UserDetails &#123; @Column(name = "username", length = 32) private String username; @Column(name = "password", length = 256) private String password; @Column(name = "account_non_expired", columnDefinition = "TINYINT(1) UNSIGNED") private Boolean accountNonExpired = true; @Column(name = "account_non_locked", columnDefinition = "TINYINT(1) UNSIGNED") private Boolean accountNonLocked = true; @Column(name = "credentials_non_expired", columnDefinition = "TINYINT(1) UNSIGNED") private Boolean credentialsNonExpired = true; @Column(name = "enabled", columnDefinition = "TINYINT(1) UNSIGNED") private Boolean enabled = true; @ManyToMany(cascade = &#123; CascadeType.MERGE &#125;, fetch = FetchType.LAZY) @JoinTable( name = "uaa_r_user_role", joinColumns = @JoinColumn(name = "user_id", referencedColumnName = "id", foreignKey = @ForeignKey(name = "none", value = ConstraintMode.NO_CONSTRAINT)), inverseJoinColumns = @JoinColumn(name = "role_id", referencedColumnName = "id", foreignKey = @ForeignKey(name = "none", value = ConstraintMode.NO_CONSTRAINT)) ) private Set&lt;Role&gt; roles = new HashSet&lt;&gt;(); @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; Set&lt;SimpleGrantedAuthority&gt; authorities = new HashSet&lt;&gt;(); roles.forEach(role -&gt; &#123; authorities.add(new SimpleGrantedAuthority(role.getRoleName())); role.getAuthorities().forEach(authority -&gt; &#123; authorities.add(new SimpleGrantedAuthority(authority.getAuthorityName())); &#125;); &#125;); return authorities; &#125; @Override public String getPassword() &#123; return password; &#125; @Override public String getUsername() &#123; return username; &#125; // 是否未过期 @Override public boolean isAccountNonExpired() &#123; return accountNonExpired; &#125; // 是否未锁定 @Override public boolean isAccountNonLocked() &#123; return accountNonLocked; &#125; // 密码是否未过期 @Override public boolean isCredentialsNonExpired() &#123; return accountNonExpired; &#125; // 是否可用 @Override public boolean isEnabled() &#123; return enabled; &#125; getter...setter...&#125; 实现UserDetailsServiceUserRepository12345public interface UserRepository extends JpaRepository&lt;User, String&gt; &#123; public Optional&lt;User&gt; findUserByUsername(String username);&#125; UserDetailsService123456789101112131415@Servicepublic class UserService implements UserDetailsService &#123; @Autowired private UserRepository userRepository; @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123; Optional&lt;User&gt; optional = userRepository.findUserByUsername(s); if(optional.isPresent()) &#123; return optional.get(); &#125; throw new UsernameNotFoundException(s); &#125;&#125; 配置WebSecurityConfig1234567891011121314151617181920212223@Configurationpublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private UserService userService; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin()// http.httpBasic() .and() .authorizeRequests() .anyRequest().authenticated(); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userService).passwordEncoder(new BCryptPasswordEncoder()); &#125;&#125; 至此为止，我们就实现了自定义用户的认证，可以尝试启动项目，并新建测试用户进行登录了。 关于UserDetails源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * Provides core user information. * * &lt;p&gt; * Implementations are not used directly by Spring Security for security purposes. They * simply store user information which is later encapsulated into &#123;@link Authentication&#125; * objects. This allows non-security related user information (such as email addresses, * telephone numbers etc) to be stored in a convenient location. * &lt;p&gt; * Concrete implementations must take particular care to ensure the non-null contract * detailed for each method is enforced. See * &#123;@link org.springframework.security.core.userdetails.User&#125; for a reference * implementation (which you might like to extend or use in your code). * * @see UserDetailsService * @see UserCache * * @author Ben Alex */public interface UserDetails extends Serializable &#123; // ~ Methods // ======================================================================================================== /** * Returns the authorities granted to the user. Cannot return &lt;code&gt;null&lt;/code&gt;. * * @return the authorities, sorted by natural key (never &lt;code&gt;null&lt;/code&gt;) */ Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); /** * Returns the password used to authenticate the user. * * @return the password */ String getPassword(); /** * Returns the username used to authenticate the user. Cannot return &lt;code&gt;null&lt;/code&gt;. * * @return the username (never &lt;code&gt;null&lt;/code&gt;) */ String getUsername(); /** * Indicates whether the user's account has expired. An expired account cannot be * authenticated. * * @return &lt;code&gt;true&lt;/code&gt; if the user's account is valid (ie non-expired), * &lt;code&gt;false&lt;/code&gt; if no longer valid (ie expired) */ boolean isAccountNonExpired(); /** * Indicates whether the user is locked or unlocked. A locked user cannot be * authenticated. * * @return &lt;code&gt;true&lt;/code&gt; if the user is not locked, &lt;code&gt;false&lt;/code&gt; otherwise */ boolean isAccountNonLocked(); /** * Indicates whether the user's credentials (password) has expired. Expired * credentials prevent authentication. * * @return &lt;code&gt;true&lt;/code&gt; if the user's credentials are valid (ie non-expired), * &lt;code&gt;false&lt;/code&gt; if no longer valid (ie expired) */ boolean isCredentialsNonExpired(); /** * Indicates whether the user is enabled or disabled. A disabled user cannot be * authenticated. * * @return &lt;code&gt;true&lt;/code&gt; if the user is enabled, &lt;code&gt;false&lt;/code&gt; otherwise */ boolean isEnabled();&#125; 解析在SpringSecurity中，用户实体都需要去实现UserDetails，才能为SpringSecurity所用，其中有几个重要的方法： Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); 返回用户的所有权限，在我们的RBAC模型中，这里需要把角色也放入这个集合中，角色的命名一定要以ROLE_为前缀，SpringSecurity才能认定它是一个角色 String getUsername(); String getPassword(); 没什么好说的，分别返回用户名和密码 boolean isAccountNonExpired(); 返回该账户是否没有过期（返回true为未过期，返回false为已过期） boolean isAccountNonLocked(); 返回该账户是否没有被锁定（返回true为未锁定，返回false为已锁定） boolean isCredentialsNonExpired(); 返回该账户的凭证(密码)是否没有过期（返回true为未过期，返回false为已过期） boolean isEnabled(); 返回该账户是否启用（返回true为启用，返回false为禁用） 总的来说，下面的四个方法，返回true均为可以登录，返回false均为无法登录，如果业务系统中并不需要这么复杂，可以直接返回true 如果我们不用认证框架，我们是怎么手动实现登录认证的基本上就是根据前端提交上来的用户名从数据库中查找这个账号的信息，然后比对密码。再进一步，可能还会添加一个字段来判断，当前用户是否已被锁定。这个接口就是这么用的。即把这些信息取出来，然后包装成一个对象交由框架去认证。 为什么还要带上权限因为登录成功后也不是什么都能访问的，还要根据你所拥有的权限进行判断。有权限你才能访问特定的对象。SpringSecurity框架是这样设计的，即认证成功后，就把用户信息和拥有的权限都存储在SecurityContext中，当访问受保护资源（某个对象/方法）的时候，就把权限拿出来比对，看看是否满足。 关于UserDetailsService源码123456789101112131415161718192021222324252627282930313233343536/** * Core interface which loads user-specific data. * &lt;p&gt; * It is used throughout the framework as a user DAO and is the strategy used by the * &#123;@link org.springframework.security.authentication.dao.DaoAuthenticationProvider * DaoAuthenticationProvider&#125;. * * &lt;p&gt; * The interface requires only one read-only method, which simplifies support for new * data-access strategies. * * @see org.springframework.security.authentication.dao.DaoAuthenticationProvider * @see UserDetails * * @author Ben Alex */public interface UserDetailsService &#123; // ~ Methods // ======================================================================================================== /** * Locates the user based on the username. In the actual implementation, the search * may possibly be case sensitive, or case insensitive depending on how the * implementation instance is configured. In this case, the &lt;code&gt;UserDetails&lt;/code&gt; * object that comes back may have a username that is of a different case than what * was actually requested.. * * @param username the username identifying the user whose data is required. * * @return a fully populated user record (never &lt;code&gt;null&lt;/code&gt;) * * @throws UsernameNotFoundException if the user could not be found or the user has no * GrantedAuthority */ UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;&#125; 解析在SpringSecurity中，加载用户信息需要实现UserDetailsService，UserDetailsService中只有一个只读方法，就是传入用户名，返回一个实现了UserDetails的类，如果当用户不存在时，抛出一个UsernameNotFoundException异常。 误解UserDetailService 负责认证用户？ 实际上：UserDetailService只单纯地负责存取用户信息，除了给框架内的其他组件提供数据外没有其他功能。而认证过程是由AuthenticationManager来完成的。（大多数情况下，可以通过实现AuthenticationProvider接口来自定义认证过程） 关于PasswordEncoder源码1234567891011121314151617181920212223242526272829303132333435363738/** * Service interface for encoding passwords. * * The preferred implementation is &#123;@code BCryptPasswordEncoder&#125;. * * @author Keith Donald */public interface PasswordEncoder &#123; /** * Encode the raw password. Generally, a good encoding algorithm applies a SHA-1 or * greater hash combined with an 8-byte or greater randomly generated salt. */ String encode(CharSequence rawPassword); /** * Verify the encoded password obtained from storage matches the submitted raw * password after it too is encoded. Returns true if the passwords match, false if * they do not. The stored password itself is never decoded. * * @param rawPassword the raw password to encode and match * @param encodedPassword the encoded password from storage to compare with * @return true if the raw password, after encoding, matches the encoded password from * storage */ boolean matches(CharSequence rawPassword, String encodedPassword); /** * Returns true if the encoded password should be encoded again for better security, * else false. The default implementation always returns false. * @param encodedPassword the encoded password to check * @return true if the encoded password should be encoded again for better security, * else false. */ default boolean upgradeEncoding(String encodedPassword) &#123; return false; &#125;&#125; 解析大多时候，我们的密码信息并不会直接明文存放在数据库中，需要进行一定的加密来存放；同时，登录时，也会使用到同样的加密算法来对密码进行对比。 在SpringSecurity中，我们只需要实现PasswordEncoder即可，它有两个重要的方法： String encode(CharSequence rawPassword); 用来对明文字符串进行编码，一般是框架使用者来调用的，例如注册时，需要调用该方法对密码字段进行加密后再存入数据库 boolean matches(CharSequence rawPassword, String encodedPassword); 用来对比密码是否匹配，一般是框架自身去调用的，登录时会调用该方法来验证密码 除此之外，还有一个默认返回false的方法：default boolean upgradeEncoding(String encodedPassword); 根据该方法的注释，该方法如果返回true，应再次对编码的密码进行编码以提高安全性，暂时还没有用过，大概猜测为进行二次验证？待后续更新 与此同时，SpringSecurity还为我们推荐了一个加密算法：BCryptPasswordEncoder 关于该加密算法具体如何实现，可以前去阅读很方便的密码加密算法BCrypt]]></content>
      <categories>
        <category>重学SpringSecurity5</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>SpringSecurity</tag>
        <tag>RBAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备战面试-反射篇]]></title>
    <url>%2F2019%2F04%2F17%2F%E5%A4%87%E6%88%98%E9%9D%A2%E8%AF%95-%E5%8F%8D%E5%B0%84%E7%AF%87%2F</url>
    <content type="text"><![CDATA[JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 获取一个类对应的Class类的方法 Object.getClass() 使用类的class成员属性 Class.forName(“类的完整路径”) 返回Class类对应的实体类的相关的Class类的方法返回当前Class类对应的实体类的父类的Class类1public Class&lt;? super T&gt; getSuperclass() 返回类定义的公共的内部类,以及从父类、父接口那里继承来的内部类1public Class&lt;?&gt;[] getClasses() 返回类中定义的公共、私有、保护的内部类1public Class&lt;?&gt;[] getDeclaredClasses() 获取Class对应类(或者接口)的修饰符1public int getModifiers() 获取Class对应的类或者接口的成员Member(成员有：属性，方法,构造方法)java.lang.reflect.Member 是一个接口，代表 Class 的成员，每个成员都有类型，分为是否从父类继承，还有是否可以直接访问。 Member 有三个实现类： java.lang.reflect.Constructor：表示该 Class 的构造函数 java.lang.reflect.Field：表示该 Class 的成员变量 java.lang.reflect.Method：表示该 Class 的成员方法 获取构造函数 返回构造器数组 12Constructor&lt;?&gt;[] getDeclaredConstructors();//返回所有的构造方法的Constructor对象的数组的Constructor对象的数组Constructor&lt;?&gt;[] getConstructors(); //返回所有共有的构造方法的Constructor对象的数组 返回指定的一个构造器 12Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes); //返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法。 Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes); //返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法。 获取成员变量 获取方法对象数组 12Method[] getMethods();//只能获取public修饰的方法数组Method[] getDeclaredMethods();//可以获取除继承外的所有方法 获取单个方法 12Method getMethod(String name, Class&lt;?&gt;... parameterTypes);//只能获取到public修饰的方法 Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes);//能获取除继承外的方法所有方法(公有，保护，默认，私有) 创建对象的方法1T newInstance(); 返回字符串(String)的方法获取当前Class表示的类的完整名字(包名.类名)1public String getName(); 获取当前Class表示的实体的简称(类名)1public String getSimpleName(); 把对象转换成String1String toString(); 返回底层类的规范化名称1String getCanonicalName(); 返回boolean的方法判断当前类是什么类123boolean isLocalClass() ;//判断是不是局部类，也就是方法里面的类 boolean isMemberClass() ;//判断是不是成员内部类，也就是一个类里面定义的类boolean isAnonymousClass() ;//判断当前类是不是匿名类，匿名类一般用于实例化接口 其他返回boolean的方法12345678boolean isAnnotation() ;//判断当前Class对象是否是注释类型boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)//如果指定类型的注释存在于此元素上，则返回 true，否则返回 false。boolean isAssignableFrom(Class&lt;?&gt; cls)//判定此 Class 对象所表示的类或接口与指定的 Class 参数所表示的类或接口是否相同，或是否是其超类或超接口。 boolean isEnum()//当且仅当该类声明为源代码中的枚举时返回 true。 boolean isInstance(Object obj)//判定指定的 Object 是否与此 Class 所表示的对象赋值兼容。 boolean isInterface()//判定指定的 Class 对象是否表示一个接口类型。 boolean isPrimitive()//判定指定的 Class 对象是否表示一个基本类型。 boolean isSynthetic()//如果此类是复合类，则返回 true，否则 false。]]></content>
      <categories>
        <category>备战面试</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>面试</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备战面试-JVM篇]]></title>
    <url>%2F2019%2F04%2F17%2F%E5%A4%87%E6%88%98%E9%9D%A2%E8%AF%95-JVM%E7%AF%87%2F</url>
    <content type="text"><![CDATA[谈谈你对Java的理解 平台无关性 GC 语言特性(泛型、反射、Lamba表达式) 面向对象 类库 异常处理 Compile Once，Run Anywhere如何实现 Java源码首先被编译成字节码，再由不同平台的JVM进行解析，Java语言在不同平台上运行时不需要进行重新编译，Java虚拟机在执行字节码的时候，把字节码转换成具体平台上的机器指令。 为什么JVM不直接将源码解析成机器码去执行 准备工作：每次执行都需要各种检查 兼容性：也可以将别的语言解析成字节码 JVM如何加载.class文件Java虚拟机JVM Class Loader：依据特定格式，加载class文件到内存 Execution Engine：对命令进行解析 Native Interface：融合不同开发语言的原生库为Java所用 Runtime Data Area：JVM内存空间结构模型 类从编译到执行的过程 编译器将xxx.java源文件编译为xxx.class字节码文件 ClassLoader将字节码转换为JVM中的Class&#60;xxx&#62;对象 JVM利用Class&#60;xxx&#62;对象实例化为Robot对象 ClassLoaderClassLoader在Java中有着非常重要的作用，它主要工作在Class装载的加载阶段，其主要作用是从系统外部获得Class二进制数据流，它是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过将Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接、初始化等操作。 ClassLoader的种类 BootStrapClassLoader：C++编写，加载核心库java.* ExtClassLoader：Java编写，加载扩展库javax.* AppClassLoader：Java编写，加载程序所在目录 自定义ClassLoader：Java编写，定制化加载 自定义ClassLoader的实现关键函数123456protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; throw new ClassNotFoundException(name);&#125;protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len) throws ClassFormatError &#123; return defineClass(name, b, off, len, null);&#125; 编写自己的ClassLoader首先在桌面上新建一个java文件，名为Robot.java 12345public class Robot &#123; static &#123; System.out.println("I am a robot"); &#125;&#125; 使用javac命令将其编译为.class文件 1234567891011121314151617181920212223242526272829303132333435package com.github.lihongjie.reflex;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;public class MyClassLoader extends ClassLoader&#123; private String classLoaderPath; public MyClassLoader(String classLoaderPath) &#123; this.classLoaderPath = classLoaderPath; &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; try &#123; Path path = Paths.get(this.classLoaderPath + name + ".class"); byte[] bytes = Files.readAllBytes(path); return defineClass(name, bytes, 0, bytes.length); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; throw new ClassNotFoundException(); &#125; public static void main(String[] args) throws Exception&#123; MyClassLoader myClassLoader = new MyClassLoader("C:\\Users\\a1320\\Desktop\\"); Class&lt;?&gt; robot = myClassLoader.findClass("Robot"); robot.newInstance(); System.out.println(robot.getClassLoader()); &#125;&#125; 运行main方法可以看到，桌面上的Robot.class已经被加载进来了 123[运行结果]I am a robotcom.github.lihongjie.reflex.MyClassLoader@4554617c 类的加载方式 隐式加载：new 显示加载：loadClass，forName等 loadClass和forName的区别类的装载过程 loadClass和forName的区别 Class.forName得到的Class是已经初始化完成的 Classloader.loadClass得到的Class是还没有链接的 JAVA内存模型内存简介 32位处理器：2^32的可寻址范围 64位处理器：2^64的可寻址范围 地址空间的划分 内核空间 用户空间 JVM内存模型——JDK8 线程私有：程序计数器、虚拟机栈、本地方法栈 线程共享：MetaSpace、Java堆 程序计数器(Program Counter Register) 当前线程所执行的字节码行号指示器(逻辑) 改变计数器的值来选取下一条需要执行的字节码指令 和线程是一对一的关系，即”线程私有“ 只对Java方法计数，如果是Native方法则计数器值为Undefined 不会发生内存泄漏 Java虚拟机栈(Stack) Java方法执行的内存模型 包含多个栈帧 局部变量表和操作数栈 局部变量表：包含方法执行过程中的所有变量 操作数栈：入栈、出栈、复制、交换、产生消费变量 示例代码123456789package com.github.lihongjie.jvm.model;public class ByteCodeSample &#123; public static int add(int a, int b) &#123; int c = 0; c = a + b; return c; &#125;&#125; 首先使用javac命令对java文件进行编译 使用javap -verbose命令对class文件反编译，并且使用口语化的方式表述出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Classfile /C:/Users/a1320/IdeaProjects/java-study/src/com/github/lihongjie/jvm/model/ByteCodeSample.class Last modified 2019-4-17; size 301 bytes MD5 checksum fa9fdfa92cae57de1bbdba6ff415385c Compiled from "ByteCodeSample.java"public class com.github.lihongjie.jvm.model.ByteCodeSample minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPER //表示该类是共有的，并且继承自ObjectConstant pool: //常量池信息 #1 = Methodref #3.#12 // java/lang/Object."&lt;init&gt;":()V #2 = Class #13 // com/github/lihongjie/jvm/model/ByteCodeSample #3 = Class #14 // java/lang/Object #4 = Utf8 &lt;init&gt; #5 = Utf8 ()V #6 = Utf8 Code #7 = Utf8 LineNumberTable #8 = Utf8 add #9 = Utf8 (II)I #10 = Utf8 SourceFile #11 = Utf8 ByteCodeSample.java #12 = NameAndType #4:#5 // "&lt;init&gt;":()V #13 = Utf8 com/github/lihongjie/jvm/model/ByteCodeSample #14 = Utf8 java/lang/Object&#123; public com.github.lihongjie.jvm.model.ByteCodeSample(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 3: 0 public static int add(int, int); descriptor: (II)I //对于方法的描述，表示接收两个int类型的参数，返回值也是int flags: ACC_PUBLIC, ACC_STATIC //修饰符 public static Code: stack=2, locals=3, args_size=2 //操作数栈=2 本地变量容量=3 参数大小=2 0: iconst_0 1: istore_2 2: iload_0 3: iload_1 4: iadd 5: istore_2 6: iload_2 7: ireturn LineNumberTable: //行号 line 5: 0 //代码第5行对应字节码第0行 line 6: 2 line 7: 6&#125;SourceFile: "ByteCodeSample.java" 执行add(1,2) 递归为什么会引发java.lang.StackOverflowError异常 递归过深，栈帧数超出虚拟栈深度 本地方法栈 与虚拟机栈相似，主要作用于标注了native的方法 JVM三大性能调优参数-Xms -Xmx -Xss的含义 -Xss：规定了每个线程虚拟机栈(堆栈)的大小 -Xms：堆的初始值 -Xmx：堆能达到的最大值 Java内存模型中堆和栈的区别——内存分配策略 静态存储：编译时确定每个数据目标在运行时的存储空间需求 栈式存储：数据区需求在编译时未知，运行时模块入口前确定 堆式存储：编译时或运行时模块入口都无法确定，动态分配 Java内存模型中堆和栈的区别 联系：引用对象、数组时，栈里定义变量保存堆中目标的首地址 管理方式：栈自动释放，堆需要GC 空间大小：栈比堆小 碎片相关：栈产生的碎片远小于堆 分配方式：栈支持静态和动态分配，而堆仅支持动态分配 效率：栈的效率比堆高 不同JDK版本之间的intern()方法的区别——JDK6 VS JDK6+JDK6：当调用intern()方法时，如果字符串常量池先前已创建出该字符串对象，则返回池中的该字符串的引用。否则，将此字符串对象添加到字符串常量池中，并且返回该字符串对象的引用。 JDK6+：当调用intern()方法时，如果字符串常量池先前已创建出该字符串对象，则返回池中的该字符串的引用。否则，如果该字符串对应已经存在于Java堆中，则将堆中对此对象的引用添加到字符串常量池中，并且返回该引用；如果堆中不存在，则在池中创建该字符串并返回其引用。]]></content>
      <categories>
        <category>备战面试</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>面试</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学SpringSecurity5（二）：基本原理]]></title>
    <url>%2F2019%2F04%2F15%2F%E9%87%8D%E5%AD%A6SpringSecurity5%20%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[上一节我们搭建了SpringSecurity的基础环境，并且使用SpringSecurity的默认认证方式完成了认证，这一节主要针对SpringSecuirty的默认配置来说明一下SpringSecurity的原理 SpringSecurity基本原理在上一节完成的默认认证中，我们访问http://localhost:8080/hello，浏览器自动跳转至http://localhost:8080/login 实际上，在SpringSecurity中，最核心的部分就是SpringSecurity过滤器链，实际上就是一组过滤器 我们的所有请求和响应都会通过SpringSecurity的过滤器，这些过滤器，在项目启动时，Springboot会自动将他们加入 接下来我们依次看一下几个比较核心的过滤器 在刚才的例子中，我们先后使用了http.formLogin()与http.httpBasic()两种认证方式，事实上，它们都各自对应如下的过滤器 UsernamePasswordAuthenticationFilter 该过滤器仅在开启了http.formLogin()时生效，检查请求中是否有用户名和密码，如果有，则尝试使用该用户名和密码进行认证；如果没有，则交给下一过滤器处理 BasicAuthenticationFilter 该过滤器检查请求头中是否含有Basic认证信息，如果有，会尝试使用Base64进行解码后的用户名密码进行认证；如果没有，则交给下一过滤器处理 任何过滤器如果完成了认证，会标记该请求已经认证成功了，后续过滤器则不再检查 接下来会来到最终的一个过滤器FilterSecurityInterceptor FilterSecurityInterceptor 该过滤器为SpringSecurity过滤器链的最后一环，它将决定请求是否能够访问服务器资源，其依据代码中的配置 12345678910111213@Configurationpublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() .and() .authorizeRequests() .anyRequest().authenticated(); &#125;&#125; 上面这段配置的含义为：任何请求都需要进行身份认证后才可以访问 然后根据该请求是否通过前面的过滤器的认证标记决定是否允许访问 如果未通过身份认证，该过滤器会抛出具体未通过认证的原因的异常 如果抛出异常，在其之前的一个过滤器ExceptionTransiationFilter将会生效 ExceptionTranslationFilter 该过滤器负责拦截FilterSecurityInterceptor抛出的异常，根据异常来引导用户进行登录或者进行别的操作 在这一整条过滤器链上，绿色的部分是可以通过配置控制其是否生效的，除此之外其他的过滤器是无法控制其生效以及顺序]]></content>
      <categories>
        <category>重学SpringSecurity5</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学SpringSecurity5（一）：基础环境]]></title>
    <url>%2F2019%2F04%2F15%2F%E9%87%8D%E5%AD%A6SpringSecurity5%20%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[前言上次使用SpringSecurity还是很久前，只实现了很简单的登录功能，现在SpringCloud大肆横行，Spring全家桶变得尤为重要 打算从头学习一下SpringSecurity，顺便梳理一下相关的知识 开发环境以及IDE： Windows10_1809 Oracle Java 1.8.0_171 Apache Maven 3.5.3 MYSQL 8.0 IntelliJ IDEA Maven依赖：123456789101112131415161718192021222324252627&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 示例代码：1.SpringsecurityDemoApplication1234567891011121314@SpringBootApplication@RestControllerpublic class SpringsecurityDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringsecurityDemoApplication.class, args); &#125; @GetMapping("/hello") public String hello() &#123; return "Hello"; &#125; &#125; 2.WebSecurityConfig1234567891011121314@Configurationpublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin()// http.httpBasic() .and() .authorizeRequests() .anyRequest().authenticated(); &#125;&#125; 在启动项目后，可以在日志中看到这一句：1Using generated security password: ca5b58f9-560b-4a7b-900d-dd85f2fb0353 这就是SpringSecurity为我们默认生成的密码 这时在浏览器中访问：http://localhost:8080/hello，会自动跳转到http://localhost:8080/login进行登录 用户名填入user，密码填入上面日志中的密码，即可跳转回http://localhost:8080/hello，在页面上显示hello 至此，基础环境已经搭建完毕，SpringSecurity为我们默认指定了formLogin的认证方式，如果需要使用httpBasic认证方式，只需要在WebSecurityConfig中改为http.httpBasic()即可]]></content>
      <categories>
        <category>重学SpringSecurity5</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备战面试-网络篇]]></title>
    <url>%2F2019%2F04%2F15%2F%E5%A4%87%E6%88%98%E9%9D%A2%E8%AF%95-%E7%BD%91%E7%BB%9C%E7%AF%87%2F</url>
    <content type="text"><![CDATA[OSI开放式互联参考模型 TCP/IP TCP传输控制协议TCP简介 面向连接的、可靠的、基于字节流的传输层通信协议 将应用层的数据流分割成报文段并发送给目标节点的TCP层 数据包都有序号，对方收到则发送ACK确认，未收到则重传 使用校验和来校验数据在传输过程中是否有误 TCP报文头 端口号：用来标识同一台计算机的不同的应用进程。 源端口 源端口和IP地址的作用是标识报文的返回地址。 目的端口 端口指明接收方计算机上的应用程序接口。 序号和确认号：是TCP可靠传输的关键部分。序号是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。e.g.一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。确认号，即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。 数据偏移/首部长度：4bits。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8 = 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。 保留：为将来定义新的用途保留，现在一般置0。 控制位：URG ACK PSH RST SYN FIN，共6个，每一个标志位表示一个控制功能。 URG：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。 ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。 PSH：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。 RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。 SYN：同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。 FIN：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。 窗口：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。 校验和：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。 紧急指针：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。 选项和填充：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。 数据部分： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。 TCP三次握手 “握手”是为了建立连接，TCP三次握手的流程如下： 第一次握手：建立连接时，客户端发送SYN包[syn=j]到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到SYN包，必须确认客户的SYN[ack=j+1]，同时自己也发送一个SYN包[syn=k]，即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK[ack=k+1]，此包发送完毕，客户端和服务器进入ESTAB-LISHED状态，完成三次握手。 为什么需要三次握手才能建立起连接为了初始化Sequence Number的初始值 首次握手的隐患——SYN超时问题起因分析 Server收到Client的SYN，回复SYN-ACK的时候未收到ACK确认 Server不断重试直至超时，Linux默认等待63秒才断开连接（5次重试，每次间隔时间翻倍，间隔识别分别为：1秒，2秒，4秒，8秒，16秒，第五次发出后，还需等待32秒） 针对SYN Flood的防护措施 SYN队列满后，通过tcp_syncookies参数回发SYN Cookie 若为正常连接则Client会回发SYN Cookie，直至建立连接 建立连接后，Client出现故障怎么办保活机制 向对方发送保活探测报文，如果未收到响应则继续发送 尝试次数达到保活探测数仍未收到响应则中断连接 TCP的四次挥手“挥手”是为了终止连接，TCP四次挥手的流程图如下： 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态； 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态； 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态； 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 为什么会有TIME_WAIT状态 确保有足够时间让对方收到ACK包 避免新旧连接混淆 为什么需要四次握手才能断开连接因为TCP是全双工的，发送方和接收方都需要FIN报文和ACK报文 服务器出现大量CLOSE_WAIT状态的原因对方关闭socket连接，我方忙于读或写，没有及时关闭连接 检查代码，特别是释放资源的代码 检查配置，特别是处理请求的线程配置 TCP的滑动窗口TCP使用滑动窗口做流量控制与乱序重排 保证TCP的可靠性 保证TCP的流控特性 RTT和RTO RTT：发送一个数据包到收到对应的ACK，所花费的时间 RTO：重传时间间隔 窗口数据的计算过程 AdvertisedWindow（接收方还可以处理的数据量） = MaxRcvBuffer（接收方能接收的最大数据量） - (LastByteRcvd - LastByteRead) EffectiveWindow（窗口内剩余可发送的数据量） = AdvertisedWindow - (LastByteSend - LastByteAcked) TCP的会话发送方 TCP的会话接收方 UDPUDP报文结构 UDP的特点 面向非连接 不维护连接状态，支持同时向多个客户端传输相同的消息 数据包报头只有8个字节，额外开销较小 吞吐量只受限于数据生成速率、传输速率以及机器性能 尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表 面向报文，不对应用程序提交的报文信息进行拆分或者合并 TCP和UDP的区别 面向连接 vs 无连接 可靠性 有序性 速度 量级 HTTP主要特点 支持客户/服务器模式 简单快速 灵活 无连接 无状态 请求结构 响应结构 请求/响应的步骤 客户端连接到Web服务器 发送HTTP请求 服务器接受请求并返回HTTP响应 释放TCP连接 客户端浏览器解析HTML内容 HTTP状态码五种可能的情况 1xx：指示信息，表示请求已接收，继续处理 2xx：成功，表示请求已被成功接收、理解、接受 3xx：重定向，要完成请求必须完成更进一步的操作 4xx：客户端错误，请求有语法错误或请求无法实现 5xx：服务端错误，服务器未能实现合法的请求 常见状态码 200 OK：正常返回信息 400 Bad Request：客户端请求有语法错误，不能被服务器所理解 401 Unauthorized：请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用 403 Forbidden：服务器收到请求，但是拒绝提供服务 404 Not Found：请求资源不存在，eg，输入了错误的URL 500 Internal Server Error：服务器发生不可预期的错误 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常 在浏览器地址栏键入URL，按下回车之后经历的流程 DNS解析(浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存) TCP连接 发送HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 连接结束 GET请求和POST请求的区别从三个层面来解答 HTTP报文层面：GET将请求信息放在URL，POST放在报文体中 数据库层面：GET符合幂等性和安全性，POST不符合 其他层面：GET可以被缓存、被存储，而POST不行 Cookie和Session的区别Cookie简介 是由服务器发给客户端的特殊信息，以文本的形式存放在客户端 客户端再次请求的时候，会把Cookie回发 服务器接收到后，会解析Cookie生成与客户端相对应的内容 Cookie的设置以及发送过程 Session简介 服务器端的机制，在服务器上保存的信息 解析客户端请求并操作session id，按需保存状态信息 Session的实现方式 使用Cookie来实现 使用URL回写来实现 Cookie和Session的区别 Cookie数据存放在客户的浏览器，Session数据放在服务器上 Session相对于Cookie更安全 若考虑减轻服务器负担，应当使用Cookie HTTP和HTTPS的区别HTTP简介HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 或 Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 SSL（Security Sockets Layer，安全套接层） 为网络通信提供安全及数据完整性的一种安全协议 是操作系统对外的API，SSL3.0后更名为TLS 采用身份验证和数据加密保证网络通信的安全和数据的完整性 加密的方式 对称加密：加密和解密都使用同一个密钥 非对称加密：加密使用的密钥和解密使用的密钥是不相同的（公钥、私钥） 哈希算法：将任意长度的信息转换为固定长度的值，算法不可逆 数字签名：证明某个消息或者文件是某人发出/认同的 HTTPS数据传输流程 浏览器将支持的加密算法信息发送给服务器 服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器 浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器 服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器 浏览器解密响应消息，并对消息进行验真，之后进行加密交互数据 HTTP和HTTPS的区别 HTTPS需要到CA申请证书，HTTP不需要 HTTPS密文传输，HTTP明文传输 连接方式不同，HTTP默认使用443端口，HTTP使用80端口 HTTPS = HTTP + 加密 + 认证 + 完整性保护，较HTTP安全 HTTPS真的很安全吗浏览器默认填充http://，请求需要认证跳转，有被劫持的风险。可以使用HSTS(HTTP Strict Transport Security)优化。 SocketSocket简介Socket是对TCP/IP协议的抽象，是操作系统对外开放的接口 Socket通信流程]]></content>
      <categories>
        <category>备战面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备战面试-多线程篇]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%A4%87%E6%88%98%E9%9D%A2%E8%AF%95-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Thread的六个状态 新建(New):创建后尚未启动的线程的状态 运行(Runnable):包含Running和Ready 无限等待期(Waiting):不会被分配CPU执行时间，需要显式被唤醒 以下为会将线程变为无限等待期的方法： 没有设置Timeout参数的Object.wait()方法 没有设置Timeout参数的Thread.join()方法 LockSupport.park()方法 限期等待(Timed Waiting):在一定时间后会由系统自动唤醒 以下为会将线程变限期等待的方法： Thread.sleep()方法 设置了Timeout参数的Object.wait()方法 设置了Timeout参数的Thread.join()方法 LockSupport.parkNanos()方法 LockSupport.parkUntil()方法 阻塞(Blocked):等待获取排它锁 结束(Terminated):已终止线程的状态，线程已经结束执行 sleep和wait sleep()是Thread的方法，wait()是Object的方法 sleep()可以在任何地方使用，wait()只能在synchronized方法或synchronized块中使用 sleep()只会让出CPU，不会导致锁行为的改变 wait()不仅让出CPU,还会释放已经占有的同步资源锁 notify()和notifyAll()​ 首先了解两个概念： 锁池EntryList假设线程A已经拥有了某个对象(不是类)的锁，而其它线程B、C想要调用这个对象的某个synchronized方法(或者块)，由于B、C线程在进入对象的synchronized方法(或者块)之前必须先获得该对象锁的拥有权，而恰巧该对象的锁目前正被线程A所占用，此时B、C线程就会被阻塞，进入一个地方去等待锁的释放，这个地方便是该对象的锁池 等待池WaitSet假设线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁，同时线程A就进入到了该对象的等待池中，进入到等待池中的线程不会去竞争该对象的锁 notifyAll()会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会 notify()只会随机选取一个处于等待池中的进程进入锁池去竞争获取锁的机会 yield当调用Thread.yield()函数时，会给线程调度器一个当前线程愿意让出CPU使用的暗示，但是线程调度器可能会忽视这个暗示。yield()不会对锁造成影响 如何中断线程已经被抛弃的方法 通过调用stop()方法停止线程 通过调用suspend()和resume()方法 目前使用的方法 调用interrupt()，通知线程应该中断了 如果线程处于被阻塞状态，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。 如果线程处于正常活动状态，那么会将该线程的中断标志设置为true。被设置中断标志的线程将继续正常运行，不受影响。 需要被调用的线程配合中断 在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。 如果线程处于正常活动状态，那么会将该线程的中断标志设置为true]]></content>
      <categories>
        <category>备战面试</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>面试</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>
