<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[备战面试-反射篇]]></title>
    <url>%2F2019%2F04%2F17%2F%E5%A4%87%E6%88%98%E9%9D%A2%E8%AF%95-%E5%8F%8D%E5%B0%84%E7%AF%87%2F</url>
    <content type="text"><![CDATA[JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 获取一个类对应的Class类的方法 Object.getClass() 使用类的class成员属性 Class.forName(“类的完整路径”) 返回Class类对应的实体类的相关的Class类的方法返回当前Class类对应的实体类的父类的Class类1public Class&lt;? super T&gt; getSuperclass() 返回类定义的公共的内部类,以及从父类、父接口那里继承来的内部类1public Class&lt;?&gt;[] getClasses() 返回类中定义的公共、私有、保护的内部类1public Class&lt;?&gt;[] getDeclaredClasses() 获取Class对应类(或者接口)的修饰符1public int getModifiers() 获取Class对应的类或者接口的成员Member(成员有：属性，方法,构造方法)java.lang.reflect.Member 是一个接口，代表 Class 的成员，每个成员都有类型，分为是否从父类继承，还有是否可以直接访问。 Member 有三个实现类： java.lang.reflect.Constructor：表示该 Class 的构造函数 java.lang.reflect.Field：表示该 Class 的成员变量 java.lang.reflect.Method：表示该 Class 的成员方法 获取构造函数 返回构造器数组 12Constructor&lt;?&gt;[] getDeclaredConstructors();//返回所有的构造方法的Constructor对象的数组的Constructor对象的数组Constructor&lt;?&gt;[] getConstructors(); //返回所有共有的构造方法的Constructor对象的数组 返回指定的一个构造器 12Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes); //返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法。 Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes); //返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法。 获取成员变量 获取方法对象数组 12Method[] getMethods();//只能获取public修饰的方法数组Method[] getDeclaredMethods();//可以获取除继承外的所有方法 获取单个方法 12Method getMethod(String name, Class&lt;?&gt;... parameterTypes);//只能获取到public修饰的方法 Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes);//能获取除继承外的方法所有方法(公有，保护，默认，私有) 创建对象的方法1T newInstance(); 返回字符串(String)的方法获取当前Class表示的类的完整名字(包名.类名)1public String getName(); 获取当前Class表示的实体的简称(类名)1public String getSimpleName(); 把对象转换成String1String toString(); 返回底层类的规范化名称1String getCanonicalName(); 返回boolean的方法判断当前类是什么类123boolean isLocalClass() ;//判断是不是局部类，也就是方法里面的类 boolean isMemberClass() ;//判断是不是成员内部类，也就是一个类里面定义的类boolean isAnonymousClass() ;//判断当前类是不是匿名类，匿名类一般用于实例化接口 其他返回boolean的方法12345678boolean isAnnotation() ;//判断当前Class对象是否是注释类型boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)//如果指定类型的注释存在于此元素上，则返回 true，否则返回 false。boolean isAssignableFrom(Class&lt;?&gt; cls)//判定此 Class 对象所表示的类或接口与指定的 Class 参数所表示的类或接口是否相同，或是否是其超类或超接口。 boolean isEnum()//当且仅当该类声明为源代码中的枚举时返回 true。 boolean isInstance(Object obj)//判定指定的 Object 是否与此 Class 所表示的对象赋值兼容。 boolean isInterface()//判定指定的 Class 对象是否表示一个接口类型。 boolean isPrimitive()//判定指定的 Class 对象是否表示一个基本类型。 boolean isSynthetic()//如果此类是复合类，则返回 true，否则 false。]]></content>
      <categories>
        <category>备战面试</category>
      </categories>
      <tags>
        <tag>备战面试</tag>
        <tag>JAVA</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备战面试-JVM篇]]></title>
    <url>%2F2019%2F04%2F17%2F%E5%A4%87%E6%88%98%E9%9D%A2%E8%AF%95-JVM%E7%AF%87%2F</url>
    <content type="text"><![CDATA[谈谈你对Java的理解 平台无关性 GC 语言特性(泛型、反射、Lamba表达式) 面向对象 类库 异常处理 Compile Once，Run Anywhere如何实现 Java源码首先被编译成字节码，再由不同平台的JVM进行解析，Java语言在不同平台上运行时不需要进行重新编译，Java虚拟机在执行字节码的时候，把字节码转换成具体平台上的机器指令。 为什么JVM不直接将源码解析成机器码去执行 准备工作：每次执行都需要各种检查 兼容性：也可以将别的语言解析成字节码 JVM如何加载.class文件Java虚拟机JVM Class Loader：依据特定格式，加载class文件到内存 Execution Engine：对命令进行解析 Native Interface：融合不同开发语言的原生库为Java所用 Runtime Data Area：JVM内存空间结构模型 类从编译到执行的过程 编译器将xxx.java源文件编译为xxx.class字节码文件 ClassLoader将字节码转换为JVM中的Class&#60;xxx&#62;对象 JVM利用Class&#60;xxx&#62;对象实例化为Robot对象 ClassLoaderClassLoader在Java中有着非常重要的作用，它主要工作在Class装载的加载阶段，其主要作用是从系统外部获得Class二进制数据流，它是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过将Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接、初始化等操作。 ClassLoader的种类 BootStrapClassLoader：C++编写，加载核心库java.* ExtClassLoader：Java编写，加载扩展库javax.* AppClassLoader：Java编写，加载程序所在目录 自定义ClassLoader：Java编写，定制化加载 自定义ClassLoader的实现关键函数123456protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; throw new ClassNotFoundException(name);&#125;protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len) throws ClassFormatError &#123; return defineClass(name, b, off, len, null);&#125; 编写自己的ClassLoader首先在桌面上新建一个java文件，名为Robot.java 12345public class Robot &#123; static &#123; System.out.println("I am a robot"); &#125;&#125; 使用javac命令将其编译为.class文件 1234567891011121314151617181920212223242526272829303132333435package com.github.lihongjie.reflex;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;public class MyClassLoader extends ClassLoader&#123; private String classLoaderPath; public MyClassLoader(String classLoaderPath) &#123; this.classLoaderPath = classLoaderPath; &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; try &#123; Path path = Paths.get(this.classLoaderPath + name + ".class"); byte[] bytes = Files.readAllBytes(path); return defineClass(name, bytes, 0, bytes.length); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; throw new ClassNotFoundException(); &#125; public static void main(String[] args) throws Exception&#123; MyClassLoader myClassLoader = new MyClassLoader("C:\\Users\\a1320\\Desktop\\"); Class&lt;?&gt; robot = myClassLoader.findClass("Robot"); robot.newInstance(); System.out.println(robot.getClassLoader()); &#125;&#125; 运行main方法可以看到，桌面上的Robot.class已经被加载进来了 123[运行结果]I am a robotcom.github.lihongjie.reflex.MyClassLoader@4554617c 类的加载方式 隐式加载：new 显示加载：loadClass，forName等 loadClass和forName的区别类的装载过程 loadClass和forName的区别 Class.forName得到的Class是已经初始化完成的 Classloader.loadClass得到的Class是还没有链接的]]></content>
      <categories>
        <category>备战面试</category>
      </categories>
      <tags>
        <tag>备战面试</tag>
        <tag>JVM</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学SpringSecurity5（二）：基本原理]]></title>
    <url>%2F2019%2F04%2F15%2F%E9%87%8D%E5%AD%A6SpringSecurity5%20%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%9A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[上一节我们搭建了SpringSecurity的基础环境，并且使用SpringSecurity的默认认证方式完成了认证，这一节主要针对SpringSecuirty的默认配置来说明一下SpringSecurity的原理 SpringSecurity基本原理在上一节完成的默认认证中，我们访问http://localhost:8080/hello，浏览器自动跳转至http://localhost:8080/login 实际上，在SpringSecurity中，最核心的部分就是SpringSecurity过滤器链，实际上就是一组过滤器 我们的所有请求和响应都会通过SpringSecurity的过滤器，这些过滤器，在项目启动时，Springboot会自动将他们加入 接下来我们依次看一下几个比较核心的过滤器 在刚才的例子中，我们先后使用了http.formLogin()与http.httpBasic()两种认证方式，事实上，它们都各自对应如下的过滤器 UsernamePasswordAuthenticationFilter 该过滤器仅在开启了http.formLogin()时生效，检查请求中是否有用户名和密码，如果有，则尝试使用该用户名和密码进行认证；如果没有，则交给下一过滤器处理 BasicAuthenticationFilter 该过滤器检查请求头中是否含有Basic认证信息，如果有，会尝试使用Base64进行解码后的用户名密码进行认证；如果没有，则交给下一过滤器处理 任何过滤器如果完成了认证，会标记该请求已经认证成功了，后续过滤器则不再检查 接下来会来到最终的一个过滤器FilterSecurityInterceptor FilterSecurityInterceptor 该过滤器为SpringSecurity过滤器链的最后一环，它将决定请求是否能够访问服务器资源，其依据代码中的配置 12345678910111213@Configurationpublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() .and() .authorizeRequests() .anyRequest().authenticated(); &#125;&#125; 上面这段配置的含义为：任何请求都需要进行身份认证后才可以访问 然后根据该请求是否通过前面的过滤器的认证标记决定是否允许访问 如果未通过身份认证，该过滤器会抛出具体未通过认证的原因的异常 如果抛出异常，在其之前的一个过滤器ExceptionTransiationFilter将会生效 ExceptionTranslationFilter 该过滤器负责拦截FilterSecurityInterceptor抛出的异常，根据异常来引导用户进行登录或者进行别的操作 在这一整条过滤器链上，绿色的部分是可以通过配置控制其是否生效的，除此之外其他的过滤器是无法控制其生效以及顺序]]></content>
      <categories>
        <category>重学SpringSecurity5</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>SpringSecurity</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学SpringSecurity5（一）：基础环境]]></title>
    <url>%2F2019%2F04%2F15%2F%E9%87%8D%E5%AD%A6SpringSecurity5%20%E7%AC%AC%E4%B8%80%E8%8A%82%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[前言上次使用SpringSecurity还是很久前，只实现了很简单的登录功能，现在SpringCloud大肆横行，Spring全家桶变得尤为重要 打算从头学习一下SpringSecurity，顺便梳理一下相关的知识 开发环境以及IDE： Windows10_1809 Oracle Java 1.8.0_171 Apache Maven 3.5.3 MYSQL 8.0 IntelliJ IDEA Maven依赖：123456789101112131415161718192021222324252627&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 示例代码：1.SpringsecurityDemoApplication1234567891011121314@SpringBootApplication@RestControllerpublic class SpringsecurityDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringsecurityDemoApplication.class, args); &#125; @GetMapping("/hello") public String hello() &#123; return "Hello"; &#125; &#125; 2.WebSecurityConfig1234567891011121314@Configurationpublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin()// http.httpBasic() .and() .authorizeRequests() .anyRequest().authenticated(); &#125;&#125; 在启动项目后，可以在日志中看到这一句：1Using generated security password: ca5b58f9-560b-4a7b-900d-dd85f2fb0353 这就是SpringSecurity为我们默认生成的密码 这时在浏览器中访问：http://localhost:8080/hello，会自动跳转到http://localhost:8080/login进行登录 用户名填入user，密码填入上面日志中的密码，即可跳转回http://localhost:8080/hello，在页面上显示hello 至此，基础环境已经搭建完毕，SpringSecurity为我们默认指定了formLogin的认证方式，如果需要使用httpBasic认证方式，只需要在WebSecurityConfig中改为http.httpBasic()即可]]></content>
      <categories>
        <category>重学SpringSecurity5</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>SpringSecurity</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备战面试-网络篇]]></title>
    <url>%2F2019%2F04%2F15%2F%E5%A4%87%E6%88%98%E9%9D%A2%E8%AF%95-%E7%BD%91%E7%BB%9C%E7%AF%87%2F</url>
    <content type="text"><![CDATA[OSI开放式互联参考模型 TCP/IP TCP传输控制协议TCP简介 面向连接的、可靠的、基于字节流的传输层通信协议 将应用层的数据流分割成报文段并发送给目标节点的TCP层 数据包都有序号，对方收到则发送ACK确认，未收到则重传 使用校验和来校验数据在传输过程中是否有误 TCP报文头 端口号：用来标识同一台计算机的不同的应用进程。 源端口 源端口和IP地址的作用是标识报文的返回地址。 目的端口 端口指明接收方计算机上的应用程序接口。 序号和确认号：是TCP可靠传输的关键部分。序号是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。e.g.一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。确认号，即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。 数据偏移/首部长度：4bits。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8 = 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。 保留：为将来定义新的用途保留，现在一般置0。 控制位：URG ACK PSH RST SYN FIN，共6个，每一个标志位表示一个控制功能。 URG：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。 ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。 PSH：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。 RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。 SYN：同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。 FIN：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。 窗口：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。 校验和：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。 紧急指针：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。 选项和填充：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。 数据部分： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。 TCP三次握手 “握手”是为了建立连接，TCP三次握手的流程如下： 第一次握手：建立连接时，客户端发送SYN包[syn=j]到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到SYN包，必须确认客户的SYN[ack=j+1]，同时自己也发送一个SYN包[syn=k]，即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK[ack=k+1]，此包发送完毕，客户端和服务器进入ESTAB-LISHED状态，完成三次握手。 为什么需要三次握手才能建立起连接为了初始化Sequence Number的初始值 首次握手的隐患——SYN超时问题起因分析 Server收到Client的SYN，回复SYN-ACK的时候未收到ACK确认 Server不断重试直至超时，Linux默认等待63秒才断开连接（5次重试，每次间隔时间翻倍，间隔识别分别为：1秒，2秒，4秒，8秒，16秒，第五次发出后，还需等待32秒） 针对SYN Flood的防护措施 SYN队列满后，通过tcp_syncookies参数回发SYN Cookie 若为正常连接则Client会回发SYN Cookie，直至建立连接 建立连接后，Client出现故障怎么办保活机制 向对方发送保活探测报文，如果未收到响应则继续发送 尝试次数达到保活探测数仍未收到响应则中断连接 TCP的四次挥手“挥手”是为了终止连接，TCP四次挥手的流程图如下： 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态； 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态； 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态； 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 为什么会有TIME_WAIT状态 确保有足够时间让对方收到ACK包 避免新旧连接混淆 为什么需要四次握手才能断开连接因为TCP是全双工的，发送方和接收方都需要FIN报文和ACK报文 服务器出现大量CLOSE_WAIT状态的原因对方关闭socket连接，我方忙于读或写，没有及时关闭连接 检查代码，特别是释放资源的代码 检查配置，特别是处理请求的线程配置 TCP的滑动窗口TCP使用滑动窗口做流量控制与乱序重排 保证TCP的可靠性 保证TCP的流控特性 RTT和RTO RTT：发送一个数据包到收到对应的ACK，所花费的时间 RTO：重传时间间隔 窗口数据的计算过程 AdvertisedWindow（接收方还可以处理的数据量） = MaxRcvBuffer（接收方能接收的最大数据量） - (LastByteRcvd - LastByteRead) EffectiveWindow（窗口内剩余可发送的数据量） = AdvertisedWindow - (LastByteSend - LastByteAcked) TCP的会话发送方 TCP的会话接收方 UDPUDP报文结构 UDP的特点 面向非连接 不维护连接状态，支持同时向多个客户端传输相同的消息 数据包报头只有8个字节，额外开销较小 吞吐量只受限于数据生成速率、传输速率以及机器性能 尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表 面向报文，不对应用程序提交的报文信息进行拆分或者合并 TCP和UDP的区别 面向连接 vs 无连接 可靠性 有序性 速度 量级 HTTP主要特点 支持客户/服务器模式 简单快速 灵活 无连接 无状态 请求结构 响应结构 请求/响应的步骤 客户端连接到Web服务器 发送HTTP请求 服务器接受请求并返回HTTP响应 释放TCP连接 客户端浏览器解析HTML内容 HTTP状态码五种可能的情况 1xx：指示信息，表示请求已接收，继续处理 2xx：成功，表示请求已被成功接收、理解、接受 3xx：重定向，要完成请求必须完成更进一步的操作 4xx：客户端错误，请求有语法错误或请求无法实现 5xx：服务端错误，服务器未能实现合法的请求 常见状态码 200 OK：正常返回信息 400 Bad Request：客户端请求有语法错误，不能被服务器所理解 401 Unauthorized：请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用 403 Forbidden：服务器收到请求，但是拒绝提供服务 404 Not Found：请求资源不存在，eg，输入了错误的URL 500 Internal Server Error：服务器发生不可预期的错误 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常 在浏览器地址栏键入URL，按下回车之后经历的流程 DNS解析(浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存) TCP连接 发送HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 连接结束 GET请求和POST请求的区别从三个层面来解答 HTTP报文层面：GET将请求信息放在URL，POST放在报文体中 数据库层面：GET符合幂等性和安全性，POST不符合 其他层面：GET可以被缓存、被存储，而POST不行 Cookie和Session的区别Cookie简介 是由服务器发给客户端的特殊信息，以文本的形式存放在客户端 客户端再次请求的时候，会把Cookie回发 服务器接收到后，会解析Cookie生成与客户端相对应的内容 Cookie的设置以及发送过程 Session简介 服务器端的机制，在服务器上保存的信息 解析客户端请求并操作session id，按需保存状态信息 Session的实现方式 使用Cookie来实现 使用URL回写来实现 Cookie和Session的区别 Cookie数据存放在客户的浏览器，Session数据放在服务器上 Session相对于Cookie更安全 若考虑减轻服务器负担，应当使用Cookie HTTP和HTTPS的区别HTTP简介HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 或 Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 SSL（Security Sockets Layer，安全套接层） 为网络通信提供安全及数据完整性的一种安全协议 是操作系统对外的API，SSL3.0后更名为TLS 采用身份验证和数据加密保证网络通信的安全和数据的完整性 加密的方式 对称加密：加密和解密都使用同一个密钥 非对称加密：加密使用的密钥和解密使用的密钥是不相同的（公钥、私钥） 哈希算法：将任意长度的信息转换为固定长度的值，算法不可逆 数字签名：证明某个消息或者文件是某人发出/认同的 HTTPS数据传输流程 浏览器将支持的加密算法信息发送给服务器 服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器 浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器 服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器 浏览器解密响应消息，并对消息进行验真，之后进行加密交互数据 HTTP和HTTPS的区别 HTTPS需要到CA申请证书，HTTP不需要 HTTPS密文传输，HTTP明文传输 连接方式不同，HTTP默认使用443端口，HTTP使用80端口 HTTPS = HTTP + 加密 + 认证 + 完整性保护，较HTTP安全 HTTPS真的很安全吗浏览器默认填充http://，请求需要认证跳转，有被劫持的风险。可以使用HSTS(HTTP Strict Transport Security)优化。 SocketSocket简介Socket是对TCP/IP协议的抽象，是操作系统对外开放的接口 Socket通信流程]]></content>
      <categories>
        <category>备战面试</category>
      </categories>
      <tags>
        <tag>备战面试</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备战面试-多线程篇]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%A4%87%E6%88%98%E9%9D%A2%E8%AF%95-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Thread的六个状态 新建(New):创建后尚未启动的线程的状态 运行(Runnable):包含Running和Ready 无限等待期(Waiting):不会被分配CPU执行时间，需要显式被唤醒 以下为会将线程变为无限等待期的方法： 没有设置Timeout参数的Object.wait()方法 没有设置Timeout参数的Thread.join()方法 LockSupport.park()方法 限期等待(Timed Waiting):在一定时间后会由系统自动唤醒 以下为会将线程变限期等待的方法： Thread.sleep()方法 设置了Timeout参数的Object.wait()方法 设置了Timeout参数的Thread.join()方法 LockSupport.parkNanos()方法 LockSupport.parkUntil()方法 阻塞(Blocked):等待获取排它锁 结束(Terminated):已终止线程的状态，线程已经结束执行 sleep和wait sleep()是Thread的方法，wait()是Object的方法 sleep()可以在任何地方使用，wait()只能在synchronized方法或synchronized块中使用 sleep()只会让出CPU，不会导致锁行为的改变 wait()不仅让出CPU,还会释放已经占有的同步资源锁 notify()和notifyAll()​ 首先了解两个概念： 锁池EntryList假设线程A已经拥有了某个对象(不是类)的锁，而其它线程B、C想要调用这个对象的某个synchronized方法(或者块)，由于B、C线程在进入对象的synchronized方法(或者块)之前必须先获得该对象锁的拥有权，而恰巧该对象的锁目前正被线程A所占用，此时B、C线程就会被阻塞，进入一个地方去等待锁的释放，这个地方便是该对象的锁池 等待池WaitSet假设线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁，同时线程A就进入到了该对象的等待池中，进入到等待池中的线程不会去竞争该对象的锁 notifyAll()会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会 notify()只会随机选取一个处于等待池中的进程进入锁池去竞争获取锁的机会 yield当调用Thread.yield()函数时，会给线程调度器一个当前线程愿意让出CPU使用的暗示，但是线程调度器可能会忽视这个暗示。yield()不会对锁造成影响 如何中断线程已经被抛弃的方法 通过调用stop()方法停止线程 通过调用suspend()和resume()方法 目前使用的方法 调用interrupt()，通知线程应该中断了 如果线程处于被阻塞状态，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。 如果线程处于正常活动状态，那么会将该线程的中断标志设置为true。被设置中断标志的线程将继续正常运行，不受影响。 需要被调用的线程配合中断 在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。 如果线程处于正常活动状态，那么会将该线程的中断标志设置为true]]></content>
      <categories>
        <category>备战面试</category>
      </categories>
      <tags>
        <tag>备战面试</tag>
        <tag>JAVA</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>
